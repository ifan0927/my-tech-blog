<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on I-Fan's Tech Blog</title><link>https://ifan0927.github.io/my-tech-blog/tags/golang/</link><description>Recent content in Golang on I-Fan's Tech Blog</description><generator>Hugo</generator><language>zh-tw</language><lastBuildDate>Wed, 19 Nov 2025 00:06:34 +0800</lastBuildDate><atom:link href="https://ifan0927.github.io/my-tech-blog/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>DTOs data mapping and Router in Go gin framework</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025_11_18_note/</link><pubDate>Wed, 19 Nov 2025 00:06:34 +0800</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025_11_18_note/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;When building REST APIs with Go and Gin framework, two fundamental challenges often emerge: handling data transfer between layers with different nullability requirements, and extracting parameters from HTTP requests. This post walks through practical solutions for DTO mapping with pointer types and demonstrates various parameter extraction patterns in Gin routers.&lt;/p&gt;
&lt;h2 id="understanding-pointer-semantics-in-dto-mapping"&gt;Understanding Pointer Semantics in DTO Mapping&lt;/h2&gt;
&lt;h3 id="the-core-challenge"&gt;The Core Challenge&lt;/h3&gt;
&lt;p&gt;When mapping between domain models and DTOs, mismatched pointer types create compilation errors. Consider this common scenario:&lt;/p&gt;</description></item><item><title>2025_11_17_Note</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025_11_17_note/</link><pubDate>Mon, 17 Nov 2025 23:40:50 +0800</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025_11_17_note/</guid><description>&lt;h1 id="optimizing-database-queries-and-understanding-hash-maps-in-go"&gt;Optimizing Database Queries and Understanding Hash Maps in Go&lt;/h1&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Today&amp;rsquo;s session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.&lt;/p&gt;
&lt;h2 id="the-n1-query-problem-in-room-api"&gt;The N+1 Query Problem in Room API&lt;/h2&gt;
&lt;h3 id="identifying-the-anti-pattern"&gt;Identifying the Anti-Pattern&lt;/h3&gt;
&lt;p&gt;While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:&lt;/p&gt;</description></item></channel></rss>