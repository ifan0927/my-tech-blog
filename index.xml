<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>I-Fan's Tech Blog</title><link>https://ifan0927.github.io/my-tech-blog/</link><description>Recent content on I-Fan's Tech Blog</description><generator>Hugo</generator><language>zh-tw</language><lastBuildDate>Tue, 25 Nov 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ifan0927.github.io/my-tech-blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Building n8n Automation Workflow for Hugo Blog Content Generation</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025-11-25_note/</link><pubDate>Tue, 25 Nov 2025 00:00:00 +0000</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025-11-25_note/</guid><description>&lt;p&gt;Today&amp;rsquo;s focus was on establishing an automated n8n workflow to streamline the daily note generation process for Hugo blog posts. The goal was to eliminate manual steps in transforming raw development notes into polished blog content using AI assistance.&lt;/p&gt;
&lt;h2 id="problem-statement"&gt;Problem Statement&lt;/h2&gt;
&lt;p&gt;The current workflow involves several manual steps that create friction in the content creation process:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Daily notes require manual formatting and editing after AI processing&lt;/li&gt;
&lt;li&gt;Hugo post creation involves repetitive file structure setup&lt;/li&gt;
&lt;li&gt;GitHub deployment requires manual commits and pushes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The solution involves creating an n8n automation that takes raw daily notes, processes them through Claude AI, and automatically creates properly formatted Hugo posts with GitHub integration.&lt;/p&gt;</description></item><item><title>Setting Up a Production-Ready Mac Mini M4 Development Environment</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025_11_24_note/</link><pubDate>Mon, 24 Nov 2025 22:51:55 +0800</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025_11_24_note/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;When transitioning to a new development machine, especially one intended to serve as both a local workstation and a remote development server, the setup process requires careful planning. This article documents the complete configuration of a Mac mini M4 (24GB) as a full-featured development environment, focusing on remote accessibility, containerized services, and productivity automation through n8n.&lt;/p&gt;
&lt;p&gt;The goal is clear: create a reliable, remotely accessible development hub that supports Go-based backend projects, database management, and workflow automationâ€”all while maintaining clean separation between development tools and system configurations.&lt;/p&gt;</description></item><item><title>Simplifying User Permission Management: A Practical Database Design Approach</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025_11_19_note/</link><pubDate>Thu, 20 Nov 2025 00:27:38 +0800</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025_11_19_note/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;When building a property management system, one of the first architectural decisions involves user permission management. While it&amp;rsquo;s tempting to implement Role-Based Access Control (RBAC) with its elaborate role hierarchies and permission matrices, sometimes a simpler approach proves more effective. This article explores how I designed a straightforward yet flexible permission system using MySQL and golang-migrate CLI, focusing on pragmatic solutions over theoretical completeness.&lt;/p&gt;
&lt;h2 id="the-permission-design-philosophy"&gt;The Permission Design Philosophy&lt;/h2&gt;
&lt;h3 id="why-group-based-over-role-based"&gt;Why Group-Based Over Role-Based?&lt;/h3&gt;
&lt;p&gt;In early-stage applications, especially side projects or MVPs, over-engineered permission systems often create more problems than they solve:&lt;/p&gt;</description></item><item><title>DTOs data mapping and Router in Go gin framework</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025_11_18_note/</link><pubDate>Wed, 19 Nov 2025 00:06:34 +0800</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025_11_18_note/</guid><description>&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;When building REST APIs with Go and Gin framework, two fundamental challenges often emerge: handling data transfer between layers with different nullability requirements, and extracting parameters from HTTP requests. This post walks through practical solutions for DTO mapping with pointer types and demonstrates various parameter extraction patterns in Gin routers.&lt;/p&gt;
&lt;h2 id="understanding-pointer-semantics-in-dto-mapping"&gt;Understanding Pointer Semantics in DTO Mapping&lt;/h2&gt;
&lt;h3 id="the-core-challenge"&gt;The Core Challenge&lt;/h3&gt;
&lt;p&gt;When mapping between domain models and DTOs, mismatched pointer types create compilation errors. Consider this common scenario:&lt;/p&gt;</description></item><item><title>2025_11_17_Note</title><link>https://ifan0927.github.io/my-tech-blog/posts/2025_11_17_note/</link><pubDate>Mon, 17 Nov 2025 23:40:50 +0800</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2025_11_17_note/</guid><description>&lt;h1 id="optimizing-database-queries-and-understanding-hash-maps-in-go"&gt;Optimizing Database Queries and Understanding Hash Maps in Go&lt;/h1&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Today&amp;rsquo;s session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.&lt;/p&gt;
&lt;h2 id="the-n1-query-problem-in-room-api"&gt;The N+1 Query Problem in Room API&lt;/h2&gt;
&lt;h3 id="identifying-the-anti-pattern"&gt;Identifying the Anti-Pattern&lt;/h3&gt;
&lt;p&gt;While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:&lt;/p&gt;</description></item><item><title>About Me</title><link>https://ifan0927.github.io/my-tech-blog/about/</link><pubDate>Sun, 16 Nov 2025 00:00:00 +0000</pubDate><guid>https://ifan0927.github.io/my-tech-blog/about/</guid><description>&lt;p&gt;Hi! I&amp;rsquo;m &lt;strong&gt;I-Fan&lt;/strong&gt;, a backend engineer.&lt;/p&gt;
&lt;h2 id="technical-background"&gt;Technical Background&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Primarily working with &lt;strong&gt;Java Spring Boot&lt;/strong&gt; for backend development&lt;/li&gt;
&lt;li&gt;Currently learning &lt;strong&gt;Go&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Passionate about system architecture and API design&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="this-blog"&gt;This Blog&lt;/h2&gt;
&lt;p&gt;This blog documents my technical learning journey, development insights, and project experiences.&lt;/p&gt;
&lt;h2 id="interests"&gt;Interests&lt;/h2&gt;
&lt;p&gt;Beyond coding, I enjoy listening to various genres of music.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Feel free to connect with me on &lt;a href="https://github.com/ifan0927"&gt;GitHub&lt;/a&gt;!&lt;/p&gt;</description></item><item><title/><link>https://ifan0927.github.io/my-tech-blog/posts/2024-12-19_note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ifan0927.github.io/my-tech-blog/posts/2024-12-19_note/</guid><description>&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-markdown" data-lang="markdown"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;title: &amp;#34;Go Pointer Handling and Query Optimization in Log Management API&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;date: &amp;#34;2024-12-19T00:00:00Z&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;tags: [&amp;#34;go&amp;#34;, &amp;#34;pointers&amp;#34;, &amp;#34;database-optimization&amp;#34;, &amp;#34;api-development&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;categories: [&amp;#34;backend-development&amp;#34;, &amp;#34;performance&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Today&amp;#39;s development focused on clarifying Go pointer concepts and optimizing database queries in the log management API. The main achievement was replacing individual database queries with batch operations to improve performance.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## Go Pointer Concepts and DTO Mapping
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;Gained better understanding of pointer handling in Go, particularly for DTO mapping scenarios:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;-&lt;/span&gt; **Key principle**: Always check the source data type first
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;-&lt;/span&gt; **&lt;span style="color:#e6db74"&gt;`&amp;amp;`&lt;/span&gt;**: Takes the address (gets pointer)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;-&lt;/span&gt; **&lt;span style="color:#e6db74"&gt;`*`&lt;/span&gt;**: Dereferences (gets value)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;-&lt;/span&gt; **Critical consideration**: When source is a pointer, always check for &lt;span style="color:#e6db74"&gt;`nil`&lt;/span&gt; before operations
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;-&lt;/span&gt; **Type conversion with pointers**: Must dereference first, then assign to correct pointer type
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;This understanding is crucial for safe DTO transformations and avoiding runtime panics.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## Database Query Optimization
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;### Problem
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;The original log management GET list API was inefficient - it fetched log IDs first, then performed individual queries for each accounting record.
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;### Solution
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;&lt;/span&gt;Implemented batch querying strategy to reduce database roundtrips:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;```go
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;func (s *managementLogService) GetManagementLogListByEstateId(estateId int) ([]dto.LogsListResponse, error) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	// TODO: Add pagination and filtering
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	// 1. Get all management logs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	managementLogs, err := s.managementLogRepo.FindByEstateId(uint(estateId))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	if err != nil {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		s.logger.Error(&amp;#34;Failed to fetch management logs&amp;#34;, zap.Int(&amp;#34;estateId&amp;#34;, estateId), zap.Error(err))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		return nil, err
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	if len(managementLogs) == 0 {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		return []dto.LogsListResponse{}, nil
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	// 2. Collect all log IDs
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	logIDs := make([]uint, 0, len(managementLogs))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	for _, log := range managementLogs {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		logIDs = append(logIDs, log.ID)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	// 3. Batch fetch all related accounting records
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	allAccountings, err := s.accountRepo.FindByLogIDs(logIDs)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	if err != nil {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		s.logger.Error(&amp;#34;Failed to fetch accountings for logs&amp;#34;, zap.Uints(&amp;#34;logIDs&amp;#34;, logIDs), zap.Error(err))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		return nil, err
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	// 4. Group accounting records by log ID
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	accountingMap := make(map[uint][]property.Accounting)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	for _, acc := range allAccountings {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		if acc.SourceID != nil {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;			accountingMap[*acc.SourceID] = append(accountingMap[*acc.SourceID], acc)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	// 5. Compose final results
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	result := make([]dto.LogsListResponse, 0, len(managementLogs))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	for _, log := range managementLogs {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		// Get corresponding accounting records from map (nil slice is safe if not found)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		logAccountings := accountingMap[log.ID]
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;		result = append(result, dto.ToLogListItemDto(&amp;amp;log, logAccountings))
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;	return result, nil
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Performance benefits&lt;/strong&gt;:&lt;/p&gt;</description></item></channel></rss>