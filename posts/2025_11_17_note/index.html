<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="Optimizing Database Queries and Understanding Hash Maps in Go Introduction Today&rsquo;s session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.
The N+1 Query Problem in Room API Identifying the Anti-Pattern While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:
"><meta name=keywords content=",golang,gorm,database-optimization"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://ifan0927.github.io/my-tech-blog/posts/2025_11_17_note/><title>2025_11_17_Note :: I-Fan's Tech Blog</title><link rel=stylesheet href=/my-tech-blog/main.min.2729760c629597024c5de34b40ea9f372f2b5a2a192dcdca537b7ddfa483eab8.css integrity="sha256-Jyl2DGKVlwJMXeNLQOqfNy8rWioZLc3KU3t936SD6rg=" crossorigin=anonymous><link rel=apple-touch-icon sizes=180x180 href=/my-tech-blog/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/my-tech-blog/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/my-tech-blog/favicon-16x16.png><link rel=manifest href=/my-tech-blog/site.webmanifest><link rel=mask-icon href=/my-tech-blog/safari-pinned-tab.svg color><link rel="shortcut icon" href=/my-tech-blog/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="2025_11_17_Note"><meta itemprop=description content="Optimizing Database Queries and Understanding Hash Maps in Go Introduction Today’s session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.
The N+1 Query Problem in Room API Identifying the Anti-Pattern While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:"><meta itemprop=datePublished content="2025-11-17T23:40:50+08:00"><meta itemprop=dateModified content="2025-11-17T23:40:50+08:00"><meta itemprop=wordCount content="713"><meta itemprop=keywords content="Golang,Gorm,Database-Optimization"><meta name=twitter:card content="summary"><meta name=twitter:title content="2025_11_17_Note"><meta name=twitter:description content="Optimizing Database Queries and Understanding Hash Maps in Go Introduction Today’s session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.
The N+1 Query Problem in Room API Identifying the Anti-Pattern While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:"><meta property="article:section" content="Backend Development"><meta property="article:section" content="Algorithms"><meta property="article:published_time" content="2025-11-17 23:40:50 +0800 +0800"></head><body><div class=container><header class=header><span class=header__inner><a href=/my-tech-blog style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>hello</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/my-tech-blog/about/>about</a></li><li><a href=/my-tech-blog/categories/>categories</a></li><li><a href=/my-tech-blog/posts/>posts</a></li><li><a href=/my-tech-blog/tags/>tags</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 minutes</p></div><article><h1 class=post-title><a href=https://ifan0927.github.io/my-tech-blog/posts/2025_11_17_note/>2025_11_17_Note</a></h1><div class=post-content><h1 id=optimizing-database-queries-and-understanding-hash-maps-in-go>Optimizing Database Queries and Understanding Hash Maps in Go</h1><h2 id=introduction>Introduction</h2><p>Today&rsquo;s session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.</p><h2 id=the-n1-query-problem-in-room-api>The N+1 Query Problem in Room API</h2><h3 id=identifying-the-anti-pattern>Identifying the Anti-Pattern</h3><p>While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Anti-pattern: N+1 Query</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1. Fetch all rooms (1 query)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rooms</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>roomRepo</span>.<span style=color:#a6e22e>FindAll</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>room</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>rooms</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 2. For each room, fetch its lease (N queries)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>lease</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>leaseRepo</span>.<span style=color:#a6e22e>FindByRoomIdAndLeaseIsActive</span>(<span style=color:#a6e22e>room</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 3. For each lease, fetch tenant (another N queries)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tenant</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tenantRepo</span>.<span style=color:#a6e22e>FindByLeaseID</span>(<span style=color:#a6e22e>lease</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This approach executes <code>1 + N + N</code> queries, where N is the number of rooms. For 100 rooms, that&rsquo;s potentially 201 database calls – a significant performance bottleneck.</p><h3 id=the-solution-eager-loading-with-preload>The Solution: Eager Loading with Preload</h3><p>GORM&rsquo;s <code>Preload</code> feature enables eager loading, fetching all related data in a minimal number of queries:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// FindAllWithDetails uses Preload for eager loading</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Includes active leases, tenants, and billing cycles</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RoomRepository</span>) <span style=color:#a6e22e>FindAllWithDetails</span>() ([]<span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Room</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>rooms</span> []<span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Room</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>db</span>.
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Preload</span>(<span style=color:#e6db74>&#34;Leases&#34;</span>, <span style=color:#e6db74>&#34;is_active = ?&#34;</span>, <span style=color:#66d9ef>true</span>).
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Preload</span>(<span style=color:#e6db74>&#34;Leases.LeaseTenant.Tenant&#34;</span>).
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Preload</span>(<span style=color:#e6db74>&#34;Leases.BillingCycle&#34;</span>).
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Find</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>rooms</span>).<span style=color:#a6e22e>Error</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>rooms</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Key Preload Patterns Learned:</strong></p><ul><li><strong>Basic Loading</strong>: <code>Preload("Leases")</code> loads all related leases</li><li><strong>Nested Loading</strong>: <code>Preload("Leases.LeaseTenant.Tenant")</code> traverses through relationships</li><li><strong>Conditional Loading</strong>: <code>Preload("Leases", "is_active = ?", true)</code> applies filters</li></ul><h3 id=proper-model-associations>Proper Model Associations</h3><p>Critical to making Preload work is defining associations correctly in your models:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Room Model excerpt</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// GORM Preload Associations</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// These fields define what can be preloaded from the Room model</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// They don&#39;t create new database columns</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Leases represents all leases for a room</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// []Lease indicates a Room can have multiple Leases (Has Many relationship)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// gorm:&#34;foreignKey:RoomID&#34; tells GORM that the RoomID field in Lease</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// is the foreign key linking to this Room</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// When using db.Preload(&#34;Leases&#34;), GORM queries the Lease table</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// for all records where RoomID matches this Room&#39;s ID</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Leases</span> []<span style=color:#a6e22e>Lease</span> <span style=color:#e6db74>`gorm:&#34;foreignKey:RoomID&#34;`</span>
</span></span></code></pre></div><h2 id=leetcode-two-sum--beyond-the-obvious>LeetCode: Two Sum – Beyond the Obvious</h2><h3 id=the-false-two-pointer-solution>The False Two-Pointer Solution</h3><p>My initial approach to Two Sum used what I thought was a two-pointer technique, but it was actually a disguised brute force solution with O(n²) complexity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Inefficient: Still O(n²)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>nums</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>j</span> &lt; len(<span style=color:#a6e22e>nums</span>); <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>+</span> <span style=color:#a6e22e>nums</span>[<span style=color:#a6e22e>j</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>target</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-hash-map-approach>The Hash Map Approach</h3><p>The optimal solution leverages a hash map to achieve O(n) time complexity:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>twoSum</span>(<span style=color:#a6e22e>nums</span> []<span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>int</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>num</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>nums</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>complement</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>target</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>num</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check if complement exists and it&#39;s not the same element</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>complement</span>]; <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>i</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>num</span>] = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=go-map-syntax-deep-dive>Go Map Syntax Deep Dive</h3><p>This problem introduced several important Go map idioms:</p><p><strong>1. Two-Value Query:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>complement</span>]
</span></span></code></pre></div><ul><li><code>j</code>: the value (index) if key exists</li><li><code>ok</code>: boolean indicating key existence</li></ul><p><strong>2. Existence Check:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ok</span>  <span style=color:#75715e>// true if complement exists in map</span>
</span></span></code></pre></div><p><strong>3. Element Uniqueness Validation:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>j</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>i</span>  <span style=color:#75715e>// ensures we don&#39;t use the same element twice</span>
</span></span></code></pre></div><p><strong>Combined in Conditional:</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>j</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>[<span style=color:#a6e22e>complement</span>]; <span style=color:#a6e22e>ok</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>i</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> []<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=key-takeaways>Key Takeaways</h2><p><strong>Database Performance:</strong></p><ul><li>Always be vigilant about N+1 queries when working with ORMs</li><li>GORM&rsquo;s Preload is powerful but requires proper model associations</li><li>Understand the difference between lazy and eager loading strategies</li></ul><p><strong>Algorithm Optimization:</strong></p><ul><li>Don&rsquo;t confuse similar-looking patterns (two-pointer vs. brute force)</li><li>Hash maps are often the key to reducing time complexity from O(n²) to O(n)</li><li>Go&rsquo;s multi-value return pattern (<code>value, ok := map[key]</code>) is idiomatic for safe map access</li></ul><hr><h2 id=conclusion>Conclusion</h2><ol><li>Finding N+1 queries problem by seeing the code is quite mess</li><li>Maybe Preload is the good way for some cases, but it might pulling out too much unnecessary info , so lazy loading might work sometime</li><li>Hashtable is the example of trading space for time</li></ol></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://ifan0927.github.io/my-tech-blog/tags/golang/>golang</a></span>
<span class=tag><a href=https://ifan0927.github.io/my-tech-blog/tags/gorm/>gorm</a></span>
<span class=tag><a href=https://ifan0927.github.io/my-tech-blog/tags/database-optimization/>database-optimization</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://ifan0927.github.io/my-tech-blog/categories/backend-development/>Backend Development</a></span>
<span class=tag><a href=https://ifan0927.github.io/my-tech-blog/categories/algorithms/>Algorithms</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
713 Words</p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2025-11-17 15:40</p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/my-tech-blog/bundle.min.ad54ad97364f77ede35def9096b162bb1f0b3973aa50b080f5e82fa147f6882e2a7200d7535adbf9b51bebf939f1c1ca9bbe6be87530092aca720eac4a226fda.js integrity="sha512-rVStlzZPd+3jXe+QlrFiux8LOXOqULCA9egvoUf2iC4qcgDXU1rb+bUb6/k58cHKm75r6HUwCSrKcg6sSiJv2g=="></script></body></html>