---
title: "API Development Workflow & Electric Reading System Implementation"
date: "2025-11-26T00:00:00Z"
tags: ["go", "api-development", "dto", "mapper", "database-optimization"]
categories: ["backend-development"]
---

Today focused on establishing a systematic API development workflow and implementing the electric reading system for property management. The process involved designing DTOs, mappers, and identifying database optimization opportunities.

## API Development Workflow

Established a standardized approach for basic GET API development, leveraging the existing modal/repository structure and referencing the legacy system for requirements:

1. **Requirements Analysis**: Identify response needs and required modal data
2. **DTO Design**: Create response DTOs and corresponding mappers
3. **Service Layer Design**: Plan repository calls and implement missing methods if needed
4. **Route Registration**: Register mappers and configure routes

This systematic approach ensures consistency across the codebase while facilitating the migration from the legacy system.

## Database Schema Review

During development, discovered redundant columns in the `Electric_reading` table that contain empty data after migration. Added this to the TODO list for future table structure optimization, particularly investigating the source and usage of the `note` field.

## Electric Reading System Implementation

Implemented the core electric reading functionality that returns room reading data for a given property, starting from the current year-month and projecting forward.

### Data Flow Logic
- Input: `estateId` → Extract room ID list
- Fetch active leases for rooms → Get `initialReading` (empty if no active lease)
- Query electric reading records by room ID
- Format reading dates as `YYYY_MM_DD`

### DTO Structure

```go
package electric_reading

type ElectricReadingListDto struct {
	RoomID         int       `json:"room_id"`
	InitialReading float64   `json:"initial_reading"`
	EndYear        int       `json:"end_year"`
	EndMonth       int       `json:"end_month"`
	ReadList       []Reading `json:"ReadList"`
}

type Reading struct {
	ReadingYear  int     `json:"reading_year"`
	ReadingMonth int     `json:"reading_month"`
	ReadingValue float64 `json:"reading_value"`
}
```

### Mapper Implementation

```go
package electric_reading

import (
	modal "backend/models/property"
)

func ToElectricReadingListItemDto(
	electricReading []modal.ElectricReading,
	initialReading float64,
	roomId int,
	endYear int,
	endMonth int) (ElectricReadingListDto, error) {
	
	ElectricReadingListDto := ElectricReadingListDto{
		RoomID:         roomId,
		EndYear:        endYear,
		EndMonth:       endMonth,
		InitialReading: initialReading,
	}
	
	readingList := make([]Reading, 0, len(electricReading))
	for _, reading := range electricReading {
		read := Reading{
			ReadingMonth: int(reading.ReadingDate.Month()),
			ReadingYear:  reading.ReadingDate.Year(),
			ReadingValue: reading.ReadingValue,
		}
		readingList = append(readingList, read)
	}
	
	ElectricReadingListDto.ReadList = readingList
	return ElectricReadingListDto, nil
}
```

## Quick Reference Notes

Compiled essential Go conversion and query patterns for REST API development:

**Data Conversion:**
- Number to string: `strconv.Itoa(n)`
- Unicode to character: `string(rune(n))`
- Chinese character count: `len([]rune(str))`
- Date calculation: `time.AddDate(0, -5, 0)`

**API Parameter Binding:**
- Path parameters: `c.ShouldBindUri()`
- Query parameters: `c.ShouldBindQuery()`
- Default values: `c.DefaultQuery("key", "default")`

**Database Filtering:**
- Time range queries: `WHERE date >= ? AND date < ?`

## Next Steps

- Review and optimize the `Electric_reading` table structure
- Investigate the `note` field data source and usage
- Continue implementing the remaining API endpoints following the established workflow