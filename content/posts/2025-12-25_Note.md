---
title: "GORM Transaction Management and Error Handling in Complex Business Logic"
date: 2025-12-25T00:00:00Z
tags: ["gorm", "transaction", "error-handling", "go", "backend"]
categories: ["development", "database"]
---

Today I focused on implementing the `CreateLease` business logic, which involves coordinating multiple database tables (Lease, LeaseTenant, Room, RentBill). This complexity made data consistency and atomicity critical considerations.

## GORM Transaction Implementation with Repository Pattern

When dealing with "all-or-nothing" business operations, proper transaction management is essential.

### Core Concepts

**Repository Pattern with Transaction Integration**: Our project follows a `Handler -> Service -> Repository` layered architecture. Since Repository instances are typically bound to global `db` connections, we adopted the `WithTx` pattern to enable Repository operations to participate in Service-layer transactions.

**Atomicity Guarantee**: All write operations (Create, Update) and critical state checks (like `Room.IsAvailable`) are wrapped within `s.db.Transaction` closures.

### Implementation Pattern

```go
// 1. Start transaction at Service layer
err := s.db.Transaction(func(tx *gorm.DB) error {
    // 2. Critical step: create temporary Repository instances bound to the transaction
    // All operations from these repos will execute within the same transaction
    txRoomRepo := s.roomRepo.WithTx(tx)
    txLeaseRepo := s.leaseRepo.WithTx(tx)
    
    // 3. Execute business logic
    // ... check room status ...
    // ... create lease ...
    // ... update room ...

    return nil // return nil = Commit, return error = Rollback
})
```

### Key Design Decision: Centralized Business Logic

**Accepting Complexity**: The `CreateLease` function contains the complete business flow, resulting in longer and more complex code. We confirmed this is **acceptable** because it represents a single, indivisible core business operation. Over-splitting would increase cognitive overhead and potentially break transaction integrity.

**Including Checks in Transaction**: To prevent race conditions (e.g., two people renting the same room simultaneously), critical state checks like room availability must also be performed within the transaction.

## Error Handling and Logging Strategy

Different error handling strategies apply inside and outside transaction boundaries.

### Inside Transaction

**Principle**: Focus on flow control.
**Action**: Return errors directly to trigger GORM's automatic rollback.
**Logging**:
- **System Errors (DB Errors)**: Usually **don't** log inside transactions; return errors for unified handling at outer layers.
- **Business Warnings**: For cases like "room already rented," use `s.logger.Warn` to record business events for troubleshooting, then return the error.

### Outside Transaction (Service Layer Boundary)

**Principle**: Unified error capture and recording.
**Action**: Catch errors returned from transactions.
**Logging**: Use `s.logger.Error` consistently to record failed operations with relevant context (like `roomID`, `request` data).
**Return**: Wrap errors (if needed) before returning to Handler layer.

### fmt.Errorf vs s.logger Distinction

**`s.logger` (Zap)**: Used for **recording** structured logs for developers and operations teams, supporting log levels (Info, Warn, Error) for debugging and monitoring.
**`fmt.Errorf`**: Used for **generating** error objects for program logic (`errors.Is`) or returning to calling layers. Supports `%w` for error wrapping to preserve error chains.

## Code Example: Transaction Error Handling

```go
func (s *LeaseService) CreateLease(ctx context.Context, req CreateLeaseRequest) error {
    err := s.db.Transaction(func(tx *gorm.DB) error {
        txRoomRepo := s.roomRepo.WithTx(tx)
        
        // Business validation within transaction
        room, err := txRoomRepo.GetByID(ctx, req.RoomID)
        if err != nil {
            return fmt.Errorf("failed to get room: %w", err)
        }
        
        if !room.IsAvailable {
            s.logger.Warn("attempt to rent unavailable room", 
                zap.String("roomID", req.RoomID))
            return fmt.Errorf("room is not available")
        }
        
        // Continue with lease creation...
        return nil
    })
    
    // Unified error handling outside transaction
    if err != nil {
        s.logger.Error("failed to create lease", 
            zap.String("roomID", req.RoomID),
            zap.Error(err))
        return fmt.Errorf("create lease failed: %w", err)
    }
    
    return nil
}
```

## Next Steps

- Complete batch generation logic for `RentBill` (rental bills)
- Write unit/integration tests for `CreateLease` to verify transaction rollback mechanisms
- Consider implementing circuit breaker patterns for external service calls within transactions