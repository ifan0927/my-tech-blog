---
title: "Go Pointer Handling and Query Optimization in Log Management API"
date: "2025-11-25T00:00:00Z"
tags: ["go", "pointers", "database-optimization", "api-development"]
categories: ["backend-development", "performance"]
---

Today's development focused on clarifying Go pointer concepts and optimizing database queries in the log management API. The main achievement was replacing individual database queries with batch operations to improve performance.

## Go Pointer Concepts and DTO Mapping

Gained better understanding of pointer handling in Go, particularly for DTO mapping scenarios:

- **Key principle**: Always check the source data type first
- **`&`**: Takes the address (gets pointer)
- **`*`**: Dereferences (gets value)
- **Critical consideration**: When source is a pointer, always check for `nil` before operations
- **Type conversion with pointers**: Must dereference first, then assign to correct pointer type

This understanding is crucial for safe DTO transformations and avoiding runtime panics.

## Database Query Optimization

### Problem
The original log management GET list API was inefficient - it fetched log IDs first, then performed individual queries for each accounting record.

### Solution
Implemented batch querying strategy to reduce database roundtrips:

```go
func (s *managementLogService) GetManagementLogListByEstateId(estateId int) ([]dto.LogsListResponse, error) {
	// TODO: Add pagination and filtering
	// 1. Get all management logs
	managementLogs, err := s.managementLogRepo.FindByEstateId(uint(estateId))
	if err != nil {
		s.logger.Error("Failed to fetch management logs", zap.Int("estateId", estateId), zap.Error(err))
		return nil, err
	}

	if len(managementLogs) == 0 {
		return []dto.LogsListResponse{}, nil
	}

	// 2. Collect all log IDs
	logIDs := make([]uint, 0, len(managementLogs))
	for _, log := range managementLogs {
		logIDs = append(logIDs, log.ID)
	}

	// 3. Batch fetch all related accounting records
	allAccountings, err := s.accountRepo.FindByLogIDs(logIDs)
	if err != nil {
		s.logger.Error("Failed to fetch accountings for logs", zap.Uints("logIDs", logIDs), zap.Error(err))
		return nil, err
	}

	// 4. Group accounting records by log ID
	accountingMap := make(map[uint][]property.Accounting)
	for _, acc := range allAccountings {
		if acc.SourceID != nil {
			accountingMap[*acc.SourceID] = append(accountingMap[*acc.SourceID], acc)
		}
	}

	// 5. Compose final results
	result := make([]dto.LogsListResponse, 0, len(managementLogs))
	for _, log := range managementLogs {
		// Get corresponding accounting records from map (nil slice is safe if not found)
		logAccountings := accountingMap[log.ID]
		result = append(result, dto.ToLogListItemDto(&log, logAccountings))
	}

	return result, nil
}
```

**Performance benefits**:
- Reduced N+1 query problem to 2 queries total
- Used in-memory grouping instead of multiple database calls
- Maintained data consistency with safe nil pointer handling

## Development Environment Improvements

The development workflow has significantly improved after implementing remote development setup:
- **Unified environment**: No more device switching concerns
- **Database consistency**: Eliminated synchronization issues between local environments
- **Reduced context switching**: Focus on development rather than environment management

Database migration is still managed through Go migrations for version control, though the up/down migration process could be more streamlined.

## Next Steps

1. **Add pagination support** to the log management API
2. **Implement filtering mechanisms** for better query flexibility
3. **Optimize migration workflow** to reduce manual intervention
4. **Consider caching strategies** for frequently accessed log data

The current batch query approach provides a solid foundation for these enhancements while maintaining good performance characteristics.
```
