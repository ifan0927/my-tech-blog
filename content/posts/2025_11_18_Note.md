---
title: "DTOs data mapping and Router in Go gin framework"
date: 2025-11-19T00:06:34+08:00
draft: false
toc: false
images:
tags:
  - golang
  - gin-framework
categories:
  - Backend Development
---

## Introduction

When building REST APIs with Go and Gin framework, two fundamental challenges often emerge: handling data transfer between layers with different nullability requirements, and extracting parameters from HTTP requests. This post walks through practical solutions for DTO mapping with pointer types and demonstrates various parameter extraction patterns in Gin routers.

## Understanding Pointer Semantics in DTO Mapping

### The Core Challenge

When mapping between domain models and DTOs, mismatched pointer types create compilation errors. Consider this common scenario:

```go
// Domain Model (Source)
type Tenant struct {
    Name  string   // Non-pointer
    Phone *string  // Pointer (nullable)
}

// DTO (Target)
type TenantDto struct {
    Name  *string  // Pointer (nullable in API)
    Phone *string  // Pointer (nullable in API)
}
```

### Three Mapping Scenarios

**Scenario 1: Non-pointer to Pointer**

When the source field is a concrete value but the DTO expects a pointer:

```go
// ❌ Direct assignment fails
dto.Name = tenant.Name  // Type mismatch

// ✅ Take the address
dto.Name = &tenant.Name
```

**Scenario 2: Pointer to Pointer**

When both types use pointers, direct assignment works:

```go
// ✅ Direct assignment succeeds
dto.Phone = tenant.Phone
```

**Scenario 3: Pointer to Non-pointer**

When the source is nullable but the target isn't, dereference with nil-checking:

```go
// ❌ Direct dereference fails
dto.Phone = tenant.Phone

// ✅ Safely dereference
if tenant.Phone != nil {
    dto.Phone = *tenant.Phone
}
```

### Why This Matters

The pattern reveals an important principle: **nullable fields (pointers) require explicit nil-handling**. When converting from optional to required fields, you must decide how to handle absence (default value, error, or skip). When converting required to optional, taking the address is safe because the value always exists.

## Extracting Parameters in Gin Routers

### Path Parameters

For RESTful resource identifiers embedded in URLs:

```go
// Route definition
rooms.GET("/:id", roomHandler.GetRoomByID)

// Handler implementation
func (h *RoomHandler) GetRoomByID(c *gin.Context) {
    id := c.Param("id")  // Extract path parameter
    // id contains "123" from GET /api/property/rooms/123
}
```

### Query Parameters

For optional filters and modifiers:

```go
func (h *RoomHandler) GetRoomByID(c *gin.Context) {
    include := c.Query("include")          // Returns "" if not present
    sort := c.DefaultQuery("sort", "name") // Returns "name" if not present
    // From GET /api/property/rooms/123?include=furniture&sort=price
}
```

### Multiple Path Parameters

For nested resource hierarchies:

```go
// Route definition
estates.GET("/:estateId/rooms/:roomId", handler.GetEstateRoom)

// Handler implementation
func (h *Handler) GetEstateRoom(c *gin.Context) {
    estateID := c.Param("estateId")
    roomID := c.Param("roomId")
    // From GET /api/property/estates/456/rooms/789
}
```

### Type Conversion

Path and query parameters arrive as strings. Use `strconv` for numeric conversions:

```go
import "strconv"

id := c.Param("id")
roomID, err := strconv.Atoi(id)
if err != nil {
    c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid room ID"})
    return
}
```

## Error Handling Philosophy

Go's explicit error handling extends to HTTP handlers. Always anticipate failure points:

```go
func (h *RoomHandler) GetRoomByID(c *gin.Context) {
    // 1. Extract and validate input
    id := c.Param("id")
    roomID, err := strconv.Atoi(id)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
        return
    }
    
    // 2. Perform business logic
    room, err := h.service.GetRoom(roomID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    // 3. Return success
    c.JSON(http.StatusOK, room)
}
```

This defensive approach prevents unexpected panics and provides clear error messages to API consumers.

## Development Workflow: Docker vs Native

### Hot Reload with Air

For containerized development, Air enables automatic recompilation:

```dockerfile
# Development Dockerfile
FROM golang:1.21

WORKDIR /app
RUN go install github.com/cosmtrek/air@latest

COPY . .
CMD ["air"]
```

However, maintaining separate Dockerfiles for development and production adds complexity. For simple projects, native Go development may be more straightforward—reserve Docker for production deployments and when you need environment parity.
