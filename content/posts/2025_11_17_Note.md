---
title: "2025_11_17_Note"
date: 2025-11-17T23:40:50+08:00
draft: false
toc: false
images:
tags:
  - golang
  - gorm
  - database-optimization
categories:
  - Backend Development
  - Algorithms
---

# Optimizing Database Queries and Understanding Hash Maps in Go

## Introduction

Today's session tackled two common yet crucial challenges in backend development: eliminating the N+1 query problem in a room management API and understanding the proper time complexity approach for the classic Two Sum problem. Both scenarios revealed important lessons about thinking beyond the obvious solution and leveraging the right data structures for optimal performance.

## The N+1 Query Problem in Room API

### Identifying the Anti-Pattern

While building a room query page API that aggregates data from multiple models, I initially implemented what seemed like straightforward logic:

```go
// Anti-pattern: N+1 Query
// 1. Fetch all rooms (1 query)
rooms, _ := roomRepo.FindAll()

for _, room := range rooms {
    // 2. For each room, fetch its lease (N queries)
    lease, _ := leaseRepo.FindByRoomIdAndLeaseIsActive(room.ID)
    
    // 3. For each lease, fetch tenant (another N queries)
    tenant, _ := tenantRepo.FindByLeaseID(lease.ID)
}
```

This approach executes `1 + N + N` queries, where N is the number of rooms. For 100 rooms, that's potentially 201 database calls – a significant performance bottleneck.

### The Solution: Eager Loading with Preload

GORM's `Preload` feature enables eager loading, fetching all related data in a minimal number of queries:

```go
// FindAllWithDetails uses Preload for eager loading
// Includes active leases, tenants, and billing cycles
func (r *RoomRepository) FindAllWithDetails() ([]models.Room, error) {
    var rooms []models.Room
    err := r.db.
        Preload("Leases", "is_active = ?", true).
        Preload("Leases.LeaseTenant.Tenant").
        Preload("Leases.BillingCycle").
        Find(&rooms).Error
    if err != nil {
        return nil, err
    }
    return rooms, nil
}
```

**Key Preload Patterns Learned:**
- **Basic Loading**: `Preload("Leases")` loads all related leases
- **Nested Loading**: `Preload("Leases.LeaseTenant.Tenant")` traverses through relationships
- **Conditional Loading**: `Preload("Leases", "is_active = ?", true)` applies filters

### Proper Model Associations

Critical to making Preload work is defining associations correctly in your models:

```go
// Room Model excerpt
// GORM Preload Associations
// These fields define what can be preloaded from the Room model
// They don't create new database columns

// Leases represents all leases for a room
// []Lease indicates a Room can have multiple Leases (Has Many relationship)
// gorm:"foreignKey:RoomID" tells GORM that the RoomID field in Lease
// is the foreign key linking to this Room
// When using db.Preload("Leases"), GORM queries the Lease table
// for all records where RoomID matches this Room's ID
Leases []Lease `gorm:"foreignKey:RoomID"`
```

## LeetCode: Two Sum – Beyond the Obvious

### The False Two-Pointer Solution

My initial approach to Two Sum used what I thought was a two-pointer technique, but it was actually a disguised brute force solution with O(n²) complexity:

```go
// Inefficient: Still O(n²)
for i := 0; i < len(nums); i++ {
    for j := i + 1; j < len(nums); j++ {
        if nums[i] + nums[j] == target {
            return []int{i, j}
        }
    }
}
```

### The Hash Map Approach

The optimal solution leverages a hash map to achieve O(n) time complexity:

```go
func twoSum(nums []int, target int) []int {
    m := make(map[int]int)
    
    for i, num := range nums {
        complement := target - num
        
        // Check if complement exists and it's not the same element
        if j, ok := m[complement]; ok && j != i {
            return []int{i, j}
        }
        
        m[num] = i
    }
    
    return nil
}
```

### Go Map Syntax Deep Dive

This problem introduced several important Go map idioms:

**1. Two-Value Query:**
```go
j, ok := m[complement]
```
- `j`: the value (index) if key exists
- `ok`: boolean indicating key existence

**2. Existence Check:**
```go
ok  // true if complement exists in map
```

**3. Element Uniqueness Validation:**
```go
j != i  // ensures we don't use the same element twice
```

**Combined in Conditional:**
```go
if j, ok := m[complement]; ok && j != i {
    return []int{i, j}
}
```

## Key Takeaways

**Database Performance:**
- Always be vigilant about N+1 queries when working with ORMs
- GORM's Preload is powerful but requires proper model associations
- Understand the difference between lazy and eager loading strategies

**Algorithm Optimization:**
- Don't confuse similar-looking patterns (two-pointer vs. brute force)
- Hash maps are often the key to reducing time complexity from O(n²) to O(n)
- Go's multi-value return pattern (`value, ok := map[key]`) is idiomatic for safe map access

---

## Conclusion
1. Finding N+1 queries problem by seeing the code is quite mess
2. Maybe Preload is the good way for some cases, but it might pulling out too much unnecessary info , so lazy loading might work sometime
3. Hashtable is the example of trading space for time

