---
title: "File Storage Service & Architecture Refactoring for Property Management System"
date: "2025-11-30T00:00:00Z"
tags: ["Go", "Gin", "Microservices", "File Storage", "Interface Design", "Unit Testing", "Architecture"]
categories: ["Backend Development", "System Design"]
---

Today's development focused on adding file handling services to the property management system while implementing architectural improvements for better maintainability and testability.

## File Storage Service Implementation

Given the current project complexity, I decided to implement local file storage initially while keeping the architecture flexible for future cloud storage migration. The key was designing an abstracted interface that allows seamless provider switching.

```go
package storage

import "mime/multipart"

// FileStorage defines the interface for file storage operations.
// Any storage provider (local disk, S3, GCS, etc.) should implement this interface.
type FileStorage interface {
	// UploadFile saves a file to the storage.
	// It takes the file header from a multipart form, the desired destination path within the storage,
	// and returns the full path where the file was stored, or an error.
	UploadFile(file *multipart.FileHeader, destPath string) (string, error)

	// GetFile retrieves a file from the storage.
	// It takes the full storage path of the file and returns the file content as bytes, or an error.
	// For web services, it might return a direct URL or handle streaming. For now, it returns bytes.
	GetFile(path string) ([]byte, error)

	// DeleteFile removes a file from the storage.
	// It takes the full storage path of the file and returns an error if deletion fails.
	DeleteFile(path string) error

	// GetFileTemporaryURL generates a temporary, pre-signed URL for accessing a file.
	// This is especially useful for cloud storage but can be a direct path for local storage.
	GetFileTemporaryURL(path string) (string, error)
}
```

This approach allows dependency injection during Gin startup, making it easy to swap LocalStorage for CloudStorage when migrating to services like AWS S3 or GCP Storage.

## Architecture Refactoring Insights

### Service Boundaries Adjustment

Initially, I planned to map each repository to a separate service, but this proved overly complex for a property management system. The business logic naturally aggregates around properties - estate listings need room, lease, and tenant data together. Therefore, allowing `estateService` to access multiple repositories makes more sense than strict separation.

However, the file system remains completely independent business-wise, so it deserves its own dedicated service to maintain proper separation of concerns.

### Repository Interface Design

With growing complexity, I introduced unit testing and dependency injection patterns. This required defining repository interfaces to enable proper mocking:

```go
package property

import "backend/models/property"

// IEstateRepository defines the interface for EstateRepository
// Using "I" prefix to distinguish from Service interfaces
type IEstateRepository interface {
	FindAll() ([]property.Estate, error)
	FindByID(id uint) (*property.Estate, error)
	Create(estate *property.Estate) (*property.Estate, error)
	Update(estate *property.Estate) (*property.Estate, error)
	Delete(id uint) error
}

// IRoomRepository defines the interface for RoomRepository
type IRoomRepository interface {
	CountRoomNumber(estateID uint) (int, error)
	CountOccupiedByEstateID(estateID int) (int, error)
	FindAllWithDetailsByEstateID(estateID int) ([]property.Room, error)
	FindAllRoomByEstateId(estateID int) ([]property.Room, error)
}

// Additional interfaces follow similar pattern...
```

## Bootstrap Layer Introduction

The router layer was becoming unwieldy with all the initialization logic. I extracted this to `backend/bootstrap/bootstrap.go`, creating an internal container that handles dependency injection during Gin startup. This provides better separation of concerns and easier maintenance.

## Testing & Code Quality

Introduced unit testing for the service layer and golint to improve code quality and maintainability. The interface-based approach significantly simplifies mocking and testing scenarios.

## Completed Features

Successfully implemented full CRUD operations for the estate table, providing a solid foundation for the property management system's core functionality.

## Next Steps

- Implement cloud storage providers (AWS S3, GCP Storage) using the established interface
- Expand unit test coverage across all service layers
- Continue refining the bootstrap container for better dependency management
- Add integration tests for the complete file upload workflow