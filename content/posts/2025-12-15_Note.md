---
title: "Lease Lifecycle Management: CRUD Design for Property Management System"
date: "2025-12-15T00:00:00Z"
tags: ["backend-development", "database-design", "transaction-management", "property-management"]
categories: ["Backend Architecture"]
---

Today I focused on designing the lease lifecycle management system for a property management application. The main challenge was architecting the complete CRUD operations for lease creation, modification, and termination, with particular attention to the integration between lease management and the accounting system.

## Lease Creation: Beyond Simple Database Insertion

Creating a lease involves much more than just inserting a record into the `leases` table. The process requires careful orchestration of multiple operations:

### Pre-validation Requirements

```go
// Essential checks before lease creation
func (s *LeaseService) CreateLease(ctx context.Context, req CreateLeaseRequest) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Lock room record to prevent race conditions
    var room Room
    err = tx.QueryRowContext(ctx, 
        "SELECT id, is_available FROM rooms WHERE id = ? FOR UPDATE", 
        req.RoomID).Scan(&room.ID, &room.IsAvailable)
    
    if !room.IsAvailable {
        return ErrRoomNotAvailable
    }
    
    // Validate tenants exist
    // ... tenant validation logic
}
```

### Bill Generation Strategy

The core principle is **predictable accounting**. However, different bill types require different approaches:

- **Rent Bills**: Since rental amounts and cycles are fixed, I generate **all future rent bills** immediately upon lease creation with `status = 'pending'`. This makes future queries and collections straightforward.

- **Electricity Bills**: Unlike rent bills, electricity billing cycles are determined by actual **meter reading dates**, not calendar dates. Therefore, **no electricity bills are pre-generated** during lease creation. Instead, I store the `initial_electric_reading` in the lease record as the baseline for future calculations.

## Lease Modification: Keeping It Simple

Lease updates present a critical design decision: what changes should be allowed?

### Core vs Non-Core Changes

**Core changes** (room changes, rent adjustments, lease period modifications) would severely impact pre-generated bills and create complex reconciliation scenarios. The solution: **treat core changes as "terminate old lease + create new lease"**.

**Non-core changes** (contact updates, notes, secondary tenant modifications) can be safely handled through direct updates:

```go
func (s *LeaseService) UpdateLease(ctx context.Context, leaseID int, req UpdateLeaseRequest) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Lock lease record
    _, err = tx.ExecContext(ctx, "SELECT id FROM leases WHERE id = ? FOR UPDATE", leaseID)
    
    // Handle tenant relationship changes
    if len(req.TenantIDs) > 0 {
        // Compare existing vs new tenant lists
        // Delete removed associations, insert new ones
    }
    
    // Update simple fields
    _, err = tx.ExecContext(ctx, 
        "UPDATE leases SET notes = ?, updated_at = NOW() WHERE id = ?",
        req.Notes, leaseID)
    
    return tx.Commit()
}
```

## Lease Termination: The Complex Settlement Process

Termination is the most sophisticated operation in the lease lifecycle, involving complete financial settlement.

### Event-Driven Final Billing

The **final meter reading** serves as the critical trigger event:

```go
func (s *LeaseService) TerminateLease(ctx context.Context, req TerminateLeaseRequest) error {
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // Generate final electricity bill based on final reading
    finalBill := s.generateFinalElectricityBill(req.LeaseID, req.FinalElectricReading)
    
    // Void all future pending rent bills
    _, err = tx.ExecContext(ctx,
        "UPDATE rent_bills SET status = 'void' WHERE lease_id = ? AND status = 'pending' AND due_date > ?",
        req.LeaseID, req.TerminationDate)
}
```

### Multi-Entry Accounting Records

Settlement involves multiple financial transactions with different natures:
- Deposit refund (expense)
- Electricity bill collection (income)  
- Damage compensation (income)

Each transaction type requires **separate accounting entries** to maintain clear financial records:

```go
// Multiple accounting entries for different transaction types
accountingEntries := []AccountingEntry{
    {Type: "expense", Amount: depositRefund, Description: "Deposit refund"},
    {Type: "income", Amount: finalElectricityBill, Description: "Final electricity charge"},
    {Type: "income", Amount: damageCompensation, Description: "Damage compensation"},
}
```

## Challenges & Solutions

**Challenge**: Race conditions during lease creation when multiple users attempt to rent the same room.
**Solution**: Implemented `SELECT ... FOR UPDATE` to lock room records during the transaction.

**Challenge**: Handling different billing cycles for rent vs utilities.
**Solution**: Adopted an event-driven approach where rent bills are pre-generated but electricity bills are created based on actual meter reading events.

**Challenge**: Managing complex termination settlements with multiple financial components.
**Solution**: Designed a comprehensive transaction that handles bill voidance, final bill generation, settlement calculation, and multi-entry accounting records atomically.

## Next Steps

The lease lifecycle design provides a solid foundation for the property management system. The next phase will focus on implementing the actual service layer with proper error handling, testing the transaction boundaries under concurrent access, and integrating with the front-end lease management interface.