---
title: "Simplifying User Permission Management: A Practical Database Design Approach"
date: 2025-11-20T00:27:38+08:00
draft: false
toc: false
images:
tags:
  - MySQL
  - Database Design
  - Migrations
  - golang-migrate
  - Python
  - Authentication
  - Backend Development
  - API Security

categories:
  - Backend Development
  - Database Design
---



## Introduction

When building a property management system, one of the first architectural decisions involves user permission management. While it's tempting to implement Role-Based Access Control (RBAC) with its elaborate role hierarchies and permission matrices, sometimes a simpler approach proves more effective. This article explores how I designed a straightforward yet flexible permission system using MySQL and golang-migrate CLI, focusing on pragmatic solutions over theoretical completeness.

## The Permission Design Philosophy

### Why Group-Based Over Role-Based?

In early-stage applications, especially side projects or MVPs, over-engineered permission systems often create more problems than they solve:

- **Maintenance Burden**: Complex RBAC systems require constant updates as business logic evolves
- **Query Overhead**: Multi-table joins for permission checks can impact performance
- **Development Friction**: Team members spend more time configuring roles than building features

Instead, I opted for a **group-based permission model** where permissions attach to user groups, and users inherit permissions through their group membership. This approach provides a middle ground between individual user permissions and complex role hierarchies.

### Core Design Decisions

The permission system centers around three key entities:

1. **User Groups**: Organizational permission containers (admin, boss, manager, employee, intern)
2. **Users**: Account holders assigned to specific groups
3. **Group Permissions**: HTTP method + path combinations assigned to groups

Here's the essential structure:

```sql
CREATE TABLE user_groups (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,  -- admin, boss, manager, employee, intern
    display_name VARCHAR(100) NOT NULL, -- 系統管理員, 老闆, 主管...
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    group_id INT NOT NULL DEFAULT 1,
    last_login TIMESTAMP DEFAULT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (group_id) REFERENCES user_groups(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE group_permissions (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_group_id INT NOT NULL,
    method ENUM('GET', 'POST', 'PUT', 'DELETE') NOT NULL,
    path VARCHAR(200) NOT NULL,  -- /api/estates, /api/estates/:id
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_group_id) REFERENCES user_groups(id) ON DELETE CASCADE,
    UNIQUE KEY uk_group_method_path (user_group_id, method, path)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

The beauty lies in the **API-first permission design**—permissions are defined as HTTP method + path combinations, mapping directly to RESTful endpoints.

## Implementing Database Migrations with golang-migrate CLI

### Why golang-migrate CLI?

Unlike ORM-based migrations, golang-migrate CLI provides:

- **Database Agnostic**: Works with MySQL, PostgreSQL, SQLite, etc.
- **Version Control**: Clear up/down migration pairs
- **Production Safety**: Explicit control over schema changes
- **CI/CD Integration**: Easy to integrate into deployment pipelines

### Setting Up Migrations

First, install golang-migrate:

```bash
# macOS
brew install golang-migrate

# Linux
curl -L https://github.com/golang-migrate/migrate/releases/download/v4.17.0/migrate.linux-amd64.tar.gz | tar xvz
sudo mv migrate /usr/local/bin/
```

Create a migrations directory structure:

```bash
mkdir -p migrations
cd migrations
```

### Creating the Migration File

Generate a new migration:

```bash
migrate create -ext sql -dir . -seq adding_user_groups_permissions
```

This creates two files:
- `000003_adding_user_groups_permissions.up.sql` (schema changes)
- `000003_adding_user_groups_permissions.down.sql` (rollback)

The `up` migration contains our complete schema as shown above. The naming convention `000003_` ensures proper execution order.

### Running Migrations

Execute migrations against your MySQL database:

```bash
# Run all pending migrations
migrate -path ./migrations \
        -database "mysql://user:password@tcp(localhost:3306)/property_db" \
        up

# Run specific number of migrations
migrate -path ./migrations \
        -database "mysql://user:password@tcp(localhost:3306)/property_db" \
        up 1

# Check current version
migrate -path ./migrations \
        -database "mysql://user:password@tcp(localhost:3306)/property_db" \
        version
```

### Rollback Strategy

If something goes wrong, rollback is straightforward:

```bash
# Rollback last migration
migrate -path ./migrations \
        -database "mysql://user:password@tcp(localhost:3306)/property_db" \
        down 1

# Rollback all migrations
migrate -path ./migrations \
        -database "mysql://user:password@tcp(localhost:3306)/property_db" \
        down
```

## Data Migration: Seeding Initial Groups and Users

### The Python Migration Script

After schema creation, I needed to seed initial data and migrate existing users. Here's the Python script I used:

```python
import pymysql
from datetime import datetime
import bcrypt

# Database connection
conn = pymysql.connect(
    host='localhost',
    user='root',
    password='your_password',
    database='property_db',
    charset='utf8mb4'
)
cursor = conn.cursor()

# Step 1: Insert default user groups
user_groups = [
    ('admin', '系統管理員', '擁有所有系統權限'),
    ('boss', '老闆', '查看所有資料與報表'),
    ('manager', '主管', '管理物業與房間'),
    ('employee', '員工', '處理日常業務'),
    ('intern', '實習生', '有限的查看權限')
]

for name, display_name, description in user_groups:
    cursor.execute("""
        INSERT INTO user_groups (name, display_name, description)
        VALUES (%s, %s, %s)
        ON DUPLICATE KEY UPDATE display_name=VALUES(display_name)
    """, (name, display_name, description))

conn.commit()
print("✓ User groups seeded successfully")

# Step 2: Get group IDs for reference
cursor.execute("SELECT id, name FROM user_groups")
groups = {name: id for id, name in cursor.fetchall()}

# Step 3: Migrate existing users from old system
# Assuming we have old user data to migrate
old_users = [
    {'email': 'admin@company.com', 'display_name': '系統管理員', 'group': 'admin'},
    {'email': 'boss@company.com', 'display_name': '王老闆', 'group': 'boss'},
    {'email': 'manager1@company.com', 'display_name': '李主管', 'group': 'manager'},
]

for user in old_users:
    # Generate default password (should be changed on first login)
    default_password = 'ChangeMe123!'
    password_hash = bcrypt.hashpw(default_password.encode('utf-8'), bcrypt.gensalt())
    
    cursor.execute("""
        INSERT INTO users (email, password_hash, display_name, group_id, is_active)
        VALUES (%s, %s, %s, %s, TRUE)
        ON DUPLICATE KEY UPDATE 
            display_name=VALUES(display_name),
            group_id=VALUES(group_id)
    """, (user['email'], password_hash.decode('utf-8'), user['display_name'], groups[user['group']]))

conn.commit()
print(f"✓ Migrated {len(old_users)} users successfully")

# Step 4: Seed default permissions for admin group
admin_permissions = [
    ('GET', '/api/estates'),
    ('POST', '/api/estates'),
    ('PUT', '/api/estates/:id'),
    ('DELETE', '/api/estates/:id'),
    ('GET', '/api/rooms'),
    ('POST', '/api/rooms'),
    ('PUT', '/api/rooms/:id'),
    ('DELETE', '/api/rooms/:id'),
]

admin_group_id = groups['admin']
for method, path in admin_permissions:
    cursor.execute("""
        INSERT INTO group_permissions (user_group_id, method, path)
        VALUES (%s, %s, %s)
        ON DUPLICATE KEY UPDATE method=VALUES(method)
    """, (admin_group_id, method, path))

conn.commit()
print(f"✓ Seeded {len(admin_permissions)} permissions for admin group")

cursor.close()
conn.close()
```

### Key Migration Patterns

**1. Idempotent Inserts**

```python
INSERT INTO user_groups (name, display_name, description)
VALUES (%s, %s, %s)
ON DUPLICATE KEY UPDATE display_name=VALUES(display_name)
```

This pattern ensures the script can run multiple times safely without creating duplicates.

**2. Password Hashing**

```python
password_hash = bcrypt.hashpw(default_password.encode('utf-8'), bcrypt.gensalt())
```

Always hash passwords before storage. bcrypt is industry-standard for password hashing with built-in salt generation.

**3. Group ID Mapping**

```python
cursor.execute("SELECT id, name FROM user_groups")
groups = {name: id for id, name in cursor.fetchall()}
```

Creating a dictionary mapping makes it easy to reference group IDs when inserting users.

## Why This Design Works

### API-First Permission Model

The `group_permissions` table directly maps to API endpoints:

```sql
method ENUM('GET', 'POST', 'PUT', 'DELETE') NOT NULL,
path VARCHAR(200) NOT NULL  -- /api/estates, /api/estates/:id
```

This design enables **middleware-based permission checks** in your application:

```go
// Pseudo-code for permission middleware
func CheckPermission(method, path string, userGroupID int) bool {
    var count int
    db.QueryRow(`
        SELECT COUNT(*) FROM group_permissions 
        WHERE user_group_id = ? AND method = ? AND path = ?
    `, userGroupID, method, path).Scan(&count)
    return count > 0
}
```

### Performance Advantages

This design offers several performance benefits:

1. **Single Join for Permission Checks**: Verifying permissions requires joining only two tables (users → group_permissions)
2. **Unique Constraint Optimization**: `UNIQUE KEY uk_group_method_path` prevents duplicate permissions and creates an automatic index
3. **Enum for HTTP Methods**: Using ENUM instead of VARCHAR saves storage and improves query performance

### Database-Level Integrity

Critical constraints enforced at the database level:

```sql
FOREIGN KEY (group_id) REFERENCES user_groups(id)
FOREIGN KEY (user_group_id) REFERENCES user_groups(id) ON DELETE CASCADE
```

**CASCADE deletion** ensures when a group is deleted, all associated permissions are automatically removed, preventing orphaned records.

## golang-migrate Best Practices

### Migration File Naming Convention

```
000001_create_estates_table.up.sql
000002_create_rooms_table.up.sql
000003_adding_user_groups_permissions.up.sql
```

Sequential numbering ensures proper execution order, which is critical when tables have foreign key dependencies.

### Always Create Paired Migrations

Every `up` migration should have a corresponding `down` migration:

```sql
-- 000003_adding_user_groups_permissions.down.sql
DROP TABLE IF EXISTS group_permissions;
DROP TABLE IF EXISTS users;
DROP TABLE IF EXISTS user_groups;
```

Note the **reverse order** when dropping tables to respect foreign key constraints.

### Version Control Integration

Add migrations to git:

```bash
git add migrations/
git commit -m "feat: add user groups and permissions schema"
```

This provides a complete history of schema evolution.

## Conclusion

This permission system demonstrates that effective software design often favors simplicity over complexity. By focusing on group-based permissions tied directly to API endpoints, and leveraging golang-migrate CLI for version-controlled schema management, we achieve a maintainable solution without sacrificing functionality.

The combination of SQL migrations for schema control and Python scripts for data seeding provides clear separation between structure and content, making the system easier to understand and maintain.
